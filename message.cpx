/*******************************************************************
(C) 2010 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

uses includes;

class MESSAGEWRITER
{
public:
	MESSAGEWRITER(FILE *f):fou(f),contents(""),pos(0){;}
	MESSAGEWRITER & operator ,(const string b);
	MESSAGEWRITER & operator ,(const char * b);
	MESSAGEWRITER & operator ,(unsigned int b);
	MESSAGEWRITER & operator ,(int b);
	MESSAGEWRITER & operator ,(float b);
	MESSAGEWRITER & operator ,(double b);
	~MESSAGEWRITER();
	int skiptochar(string);
	FILE *fou;
	string contents;
	int pos;
	int ipos;
	int lpos;
	string modifier;
};

#define __COND_DBG_OUT(cond,...) do { if (!(cond)) break; { MESSAGEWRITER __MW(stderr); __MW , __VA_ARGS__; }} while(0)

#define __FILE_OUT(fou,...) do { {MESSAGEWRITER __MW(fou); __MW , __VA_ARGS__;} } while(0)

#define assume(cond,...) \
	do { if (cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! ERROR !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , __VA_ARGS__ , "\n\n"; \
	} assert(0); } while(0)

#define assret(cond,...) \
	do { if (cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! FAIL !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , __VA_ARGS__ , "\n\n"; \
	} return 0; } while(0)
	
#define warnif(cond,...) \
	do { if (!cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! WARNING !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , __VA_ARGS__ , "\n\n"; \
	} } while(0)

#define assume_paranoid(cond,...) assume(cond,__VA_ARGS__)

#define MESSAGE(...) __FILE_OUT(stdout,__VA_ARGS__)


implementation

int MESSAGEWRITER::skiptochar(string c)
{
	ipos=pos;
	modifier="%";
	modifier+=c[0];
	while (pos<contents.length())
	{
		if (contents[pos++]!='%') continue;
		lpos=pos-1;
		if (contents[pos]=='%') { pos++; continue; }
		while (isdigit(contents[pos]) || contents[pos]=='.') pos++;
		if (c.find(contents[pos])==string::npos)
		{
			fprintf(fou,"!!! bad output qualifier %c, expecting \"%s\"!!!",contents[pos],c.c_str());
			return 0;
		}
		modifier=contents.substr(lpos,pos-lpos+1);
		fprintf(fou,"%s",contents.substr(ipos,lpos-ipos).c_str());
		pos++;
		return 1;
	}
	fprintf(fou,"%s",contents.substr(ipos).c_str());
	contents="";
	pos=0;
	return 0;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(const string b)
{
	if (skiptochar("s")) fprintf(fou,modifier.c_str(),b.c_str());
	else contents+=b;
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(const char * b)
{
	if (skiptochar("s")) fprintf(fou,modifier.c_str(),b);
	else contents+=b;
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(unsigned int b)
{
	skiptochar("cxd");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(int b)
{
	skiptochar("cxd");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(float b)
{
	skiptochar("f");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(double b)
{
	skiptochar("f");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER::~MESSAGEWRITER()
{
	fprintf(fou,"%s",contents.c_str()+pos);
}
